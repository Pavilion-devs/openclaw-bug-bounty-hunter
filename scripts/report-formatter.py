#!/usr/bin/env python3
"""
Report Formatter for Solana Bug Bounty Hunter

Formats vulnerability findings into professional bug bounty reports.

Usage:
    python report-formatter.py --finding-id FND-20240210-123 --output report.md
    python report-formatter.py --scan-id scan_20240210_143022 --format json
"""

import json
import os
import sys
import argparse
from datetime import datetime
from typing import Dict, List, Optional
from pathlib import Path


class ReportFormatter:
    """Formats vulnerability findings into professional reports."""
    
    def __init__(self, db_path: str = None):
        self.db_path = db_path or os.path.expanduser("~/.solana-bounty-hunter/findings.db")
    
    def format_markdown_report(self, finding: Dict) -> str:
        """
        Format a finding as a professional Markdown report.
        
        Args:
            finding: Finding dictionary
            
        Returns:
            Markdown formatted report
        """
        severity = finding.get("severity", "Unknown")
        
        # Severity badge
        severity_badge = {
            "Critical": "![Critical](https://img.shields.io/badge/Severity-Critical-red)",
            "High": "![High](https://img.shields.io/badge/Severity-High-orange)",
            "Medium": "![Medium](https://img.shields.io/badge/Severity-Medium-yellow)",
            "Low": "![Low](https://img.shields.io/badge/Severity-Low-green)",
        }.get(severity, f"![{severity}](https://img.shields.io/badge/Severity-{severity}-blue)")
        
        report = f"""# Security Vulnerability Report

{severity_badge}

## Executive Summary

**Finding ID:** {finding.get('finding_id', 'N/A')}  
**Vulnerability Type:** {finding.get('vulnerability_type', 'N/A')}  
**Affected Repository:** [{finding.get('repo_name', 'N/A')}]({finding.get('repo_url', '')})  
**Status:** {finding.get('status', 'Pending')}  
**Date Reported:** {finding.get('created_at', datetime.now().isoformat())}

---

## Vulnerability Details

### Title
{finding.get('title', 'Untitled Finding')}

### Description
{finding.get('description', 'No description provided.')}

### Location
- **File:** `{finding.get('file_path', 'N/A')}`
- **Line:** {finding.get('line_number', 'N/A')}

### Vulnerable Code
```rust
{finding.get('code_snippet', '// No code snippet available')}
```

---

## Impact Assessment

{finding.get('impact', 'No impact assessment provided.')}

### Attack Scenario
1. **Prerequisites:** Attacker needs to...
2. **Exploitation:** Attacker performs...
3. **Result:** The vulnerability allows...

---

## Recommendation

{finding.get('recommendation', 'No recommendation provided.')}

### Suggested Fix
```rust
// Secure implementation
// [Add secure code example here]
```

---

## Additional Information

- **Analyzer:** {finding.get('analyzer', 'Unknown')}
- **Confidence:** {finding.get('confidence', 0)}%
- **Scan ID:** {finding.get('scan_id', 'N/A')}

---

## Disclosure Timeline

- **Discovery Date:** {finding.get('created_at', 'N/A')}
- **Report Submitted:** {finding.get('submitted_at', 'Pending')}
- **Acknowledged:** [Pending]
- **Fixed:** [Pending]
- **Bounty Paid:** [Pending]

---

*Report generated by Solana Bug Bounty Hunter - Autonomous Security Agent*
"""
        
        return report
    
    def format_bug_bounty_submission(self, finding: Dict) -> str:
        """
        Format finding for bug bounty platform submission.
        
        Args:
            finding: Finding dictionary
            
        Returns:
            Formatted submission text
        """
        return f"""## Summary

**Vulnerability Type:** {finding.get('vulnerability_type')}  
**Severity:** {finding.get('severity')}  
**Affected Repository:** {finding.get('repo_url')}

## Description

{finding.get('description')}

## Impact

{finding.get('impact')}

## Proof of Concept

**Vulnerable Code Location:**
- File: `{finding.get('file_path')}`
- Line: {finding.get('line_number')}

```rust
{finding.get('code_snippet')}
```

## Recommended Fix

{finding.get('recommendation')}

## Additional Context

This finding was discovered through automated security analysis combined with expert review.

---

**Reporter:** Solana Bug Bounty Hunter (AI Security Agent)  
**Finding ID:** {finding.get('finding_id')}  
**Date:** {finding.get('created_at')}
"""
    
    def format_json_report(self, finding: Dict) -> str:
        """
        Format finding as JSON.
        
        Args:
            finding: Finding dictionary
            
        Returns:
            JSON string
        """
        return json.dumps(finding, indent=2)
    
    def format_scan_summary(self, scan_id: str, findings: List[Dict]) -> str:
        """
        Format a scan summary report.
        
        Args:
            scan_id: Scan identifier
            findings: List of findings
            
        Returns:
            Markdown formatted summary
        """
        # Group by severity
        by_severity = {}
        for f in findings:
            sev = f.get("severity", "Unknown")
            by_severity[sev] = by_severity.get(sev, 0) + 1
        
        report = f"""# Scan Summary Report

**Scan ID:** {scan_id}  
**Date:** {datetime.now().isoformat()}  
**Total Findings:** {len(findings)}

## Findings by Severity

| Severity | Count |
|----------|-------|
| üî¥ Critical | {by_severity.get('Critical', 0)} |
| üü† High | {by_severity.get('High', 0)} |
| üü° Medium | {by_severity.get('Medium', 0)} |
| üü¢ Low | {by_severity.get('Low', 0)} |

## Detailed Findings

"""
        
        # Sort by severity
        severity_order = ["Critical", "High", "Medium", "Low"]
        sorted_findings = sorted(
            findings,
            key=lambda x: severity_order.index(x.get("severity", "Low"))
            if x.get("severity") in severity_order
            else 999
        )
        
        for i, f in enumerate(sorted_findings, 1):
            report += f"""
### {i}. {f.get('title', 'Untitled')}
- **Severity:** {f.get('severity')}
- **Type:** {f.get('vulnerability_type')}
- **Location:** `{f.get('file_path')}:{f.get('line_number')}`
- **Finding ID:** {f.get('finding_id')}

{f.get('description', 'No description')[:200]}...

---
"""
        
        return report
    
    def format_monthly_report(self, stats: Dict, findings: List[Dict]) -> str:
        """
        Format a monthly activity report.
        
        Args:
            stats: Statistics dictionary
            findings: List of findings from the month
            
        Returns:
            Markdown formatted report
        """
        return f"""# Monthly Security Audit Report

**Period:** {datetime.now().strftime("%B %Y")}  
**Generated:** {datetime.now().isoformat()}

## Overview

This month, our autonomous security agent scanned Solana repositories and identified potential vulnerabilities.

### Statistics

- **Total Findings:** {stats.get('total_findings', 0)}
- **New This Month:** {len(findings)}
- **Submissions:** {stats.get('submissions', 0)}
- **Earnings:** ${stats.get('total_earnings', 0):,.2f}

### Severity Breakdown

- üî¥ Critical: {stats.get('by_severity', {}).get('Critical', 0)}
- üü† High: {stats.get('by_severity', {}).get('High', 0)}
- üü° Medium: {stats.get('by_severity', {}).get('Medium', 0)}
- üü¢ Low: {stats.get('by_severity', {}).get('Low', 0)}

### Status Distribution

- ‚è≥ Pending: {stats.get('by_status', {}).get('pending', 0)}
- ‚úÖ Approved: {stats.get('by_status', {}).get('approved', 0)}
- üì§ Submitted: {stats.get('by_status', {}).get('submitted', 0)}
- üí∞ Paid: {stats.get('by_status', {}).get('paid', 0)}
- ‚ùå Rejected: {stats.get('by_status', {}).get('rejected', 0)}

## Top Findings This Month

"""


def load_finding_from_db(finding_id: str, db_path: str = None) -> Optional[Dict]:
    """Load finding from database."""
    try:
        import sqlite3
        
        if not db_path:
            db_path = os.path.expanduser("~/.solana-bounty-hunter/findings.db")
        
        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("SELECT * FROM findings WHERE finding_id = ?", (finding_id,))
        row = cursor.fetchone()
        conn.close()
        
        return dict(row) if row else None
        
    except Exception as e:
        print(f"Error loading finding: {e}")
        return None


def load_findings_from_scan(scan_id: str, db_path: str = None) -> List[Dict]:
    """Load all findings from a scan."""
    try:
        import sqlite3
        
        if not db_path:
            db_path = os.path.expanduser("~/.solana-bounty-hunter/findings.db")
        
        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row
        cursor = conn.cursor()
        
        cursor.execute("SELECT * FROM findings WHERE scan_id = ?", (scan_id,))
        rows = cursor.fetchall()
        conn.close()
        
        return [dict(row) for row in rows]
        
    except Exception as e:
        print(f"Error loading findings: {e}")
        return []


def main():
    parser = argparse.ArgumentParser(description="Report Formatter for Bug Bounty Hunter")
    parser.add_argument("--finding-id", help="Finding ID to format")
    parser.add_argument("--scan-id", help="Scan ID to summarize")
    parser.add_argument("--format", choices=["markdown", "bounty", "json"], default="markdown",
                       help="Output format")
    parser.add_argument("--output", help="Output file path")
    parser.add_argument("--db", help="Database path")
    
    args = parser.parse_args()
    
    formatter = ReportFormatter(args.db)
    
    if args.finding_id:
        finding = load_finding_from_db(args.finding_id, args.db)
        if not finding:
            print(f"‚ùå Finding {args.finding_id} not found")
            sys.exit(1)
        
        if args.format == "markdown":
            report = formatter.format_markdown_report(finding)
        elif args.format == "bounty":
            report = formatter.format_bug_bounty_submission(finding)
        elif args.format == "json":
            report = formatter.format_json_report(finding)
        else:
            report = formatter.format_markdown_report(finding)
        
        if args.output:
            with open(args.output, 'w') as f:
                f.write(report)
            print(f"‚úÖ Report saved to {args.output}")
        else:
            print(report)
    
    elif args.scan_id:
        findings = load_findings_from_scan(args.scan_id, args.db)
        if not findings:
            print(f"‚ùå No findings found for scan {args.scan_id}")
            sys.exit(1)
        
        report = formatter.format_scan_summary(args.scan_id, findings)
        
        if args.output:
            with open(args.output, 'w') as f:
                f.write(report)
            print(f"‚úÖ Summary saved to {args.output}")
        else:
            print(report)
    
    else:
        parser.print_help()


if __name__ == "__main__":
    main()
